# Danmaku2Local

Danmaku2Local 是一个自动抓取在线弹幕并与本地视频匹配的工具。

## 整体设计：

### 程序模块划分：

- Danmaku2Local

- 抓取在线弹幕

  - b站弹幕xml
  - xml弹幕转ass弹幕
  - 多次抓取合并
- 匹配本地视频

  - 视频文件识别
  - 获取视频元数据
- 匹配本地字幕

  - 获取视频中嵌入的字幕
  - 将多个ass字幕合并为一个ass字幕
  - 将其他格式字幕转为ass格式
  - 调整ass字幕时间轴
- 操作工具

  - 命令行工具
  - 交互式命令行
- 存储

  - 全局配置存储
  - 局部配置存储
  - 中间结果（xml，ass，时间轴设置等）存储

### 程序流程：

```mermaid
flowchart LR
subgraph r[抓取在线弹幕]
    bili[b站弹幕xml]
    xml2ass[xml弹幕转ass弹幕]
    multi[多次抓取合并]
end
subgraph l[匹配本地视频]
    videofile[视频文件识别]
    videometa[获取视频元数据]
    videosub[获取视频中嵌入的字幕]
end
subgraph sub[匹配本地字幕]
    subfile[字幕文件识别]
    subjoin[将多个ass字幕合并为一个ass字幕]
    sub2ass[将其他格式字幕转化为ass字幕]
    subtimeline[调整ass字幕时间轴]
end
subgraph tool[操作工具]
    toolcli[命令行工具]
    toolscript[交互式命令行]
end
subgraph util[存储]
    global[全局配置存储]
    local[局部配置存储]
    midresult[中间结果]
end
tags[标记匹配模块]

tool --视频目录和匹配规则--> videofile %% --视频文件名和元数据--> tool
%% tool --弹幕来源URL--> r --目标弹幕ass--> tool
tool --弹幕来源URL--> multi %% --目标弹幕ass--> tool
tool --目录和匹配规则--> subfile %% --视频字幕ass--> tool
tool --弹幕ass和时间轴配置--> subtimeline %% --调整后的ass--> tool
tool --视频字幕ass和弹幕ass--> subjoin %% --合并ass--> tool
tool --访问--> util

%% l
videofile --> videometa
%% r
multi --> xml2ass --> bili
multi --> subjoin
%% sub
subfile --> sub2ass
subfile --> videosub
%% tags
videofile --> tags
bili --> tags
subfile --> tags
```

## 各模块设计：

### 操作工具：

交互式命令行将各模块功能包装为命令；命令行工具将交互式命令行组织为脚本

为了调试方便应当包括一个重放上次执行参数的功能

### 本地视频：

1. 视频文件识别
   1. 给定目录，找出目录下所有视频文件（通过后缀名或魔数）
   2. 获取视频文件的元数据
   3. 根据文件名和元数据给视频打[标记](#标记)
2. 获取视频元数据
   - 用`ffmpeg`

3. 获取视频中嵌入的字幕
   - 用`ffmpeg`

### 在线弹幕：

1. b站弹幕xml
   1. 根据各种输入获取一季中各集的cid及元数据
   2. 使用已知api获取弹幕
   3. 根据元数据给各个弹幕打[标记](#标记)
2. xml弹幕转ass弹幕
   - 使用外部工具`danmaku2ass`
3. 多次抓取合并
   - 多次运行抓取弹幕操作

### 本地字幕：

1. 字幕文件识别
   1. 给定目录，找出目录下的所有字幕文件（通过后缀名）
   2. 根据文件名给字幕打[标记](#标记)
2. 将多个ass字幕合并为一个ass字幕
   - 需要所有ass字幕的分辨率相同
3. 将其他格式字幕转化为ass字幕
   - 待实现
4. 调整ass字幕时间轴
   - 输入时间轴操作指令，输出调整后的ass

### 存储：

1. 全局设置json/pickle
   - 默认样式、过滤配置、脚本等
2. 局部设置json/pickle
   - 当前样式、过滤配置、脚本等，以及指向中间结果的元数据
3. 中间结果xml/ass

### 标记匹配模块

#### 标记匹配模块原理

标记匹配模块是本工具的核心，该模块提供了将视频、弹幕、字幕三者互相匹配的能力。该模块首先将视频、弹幕、字幕分别进行标记，然后让标记相互匹配。

标记的目标是找到一个对象在整季中的集数（以及季数），由于有些情况下集数并不是按整数顺序自然排列的，标记的结果并不只有一个数，而是包含了其他可能有用的信息。
<!-- - 对于文件名生成标记的情况（这也是最主要的情况之一），标记需要根据文件名之间的关系找出文件名中标志季数和集数的字段，以及这些字段附近一些补充或代替出现的标签（比如`OVA`，`END`，`.5`，`β`之类）
  - 对于同一来源的一组文件名，应当尽量寻找其中有相同格式的部分
  - 在去除相同格式的部分之后，需要寻找看上去类似标号的部分，也就是能依次代表`1`、`2`、`3`等序号的部分
  - 保留序号以及序号前后的痕迹作为标记
- 对于弹幕元数据生成标记的情况（这是另一种最主要的情况）由于弹幕元数据以一个数组的形式提供，

1. 根据数据源生成标记
   - 视频数据源包含文件名和元数据
   - 字幕数据源包含文件名
   - 弹幕数据源包含序号、偏移量、标题及其他元数据
2. 根据文件名生成标记
   - 同一数据源的文件名需要一起标记
   - 生成一个尽量小的有向无环图，使得图中包含的路径各节点串起来可以得到每个文件名
     - 使用最长子序列辅助生成
   - 捕捉文件名中标志集数的变量
3. 将标记相互匹配起来 -->
- 对于文件名生成标记的情况（这也是最主要的情况之一），标记需要根据文件名之间的关系找出文件名中标志季数和集数的字段，以及这些字段附近一些补充或代替出现的标签（比如`OVA`，`END`，`.5`，`β`之类）
  - 需要寻找看上去类似标号的部分，也就是能依次代表`1`、`2`、`3`等序号的部分
  - 保留序号以及序号前后的痕迹作为标记
  - 一个文件名可能生成多个标记
  - 对没有序号的文件名来说，我们也给它生成一个特殊的标记代替整数序号
- 对于弹幕元数据生成标记的情况（这是另一种最主要的情况）由于弹幕元数据以一个数组的形式提供，每集包含的元数据包括数组偏移量和序号两个值（其中序号是字符串，不一定是纯数字），我们把序号和偏移量+1都作为标记（因为偏移量从0开始），如果序号不含数字，给序号分配一个特殊标记
- 匹配标记的过程会依次使用多个规则尝试匹配。
  - 首先尝试让字幕和视频的文件名进行全文匹配，如果字幕的文件名是视频文件名（+语言后缀）的格式，就直接将二者匹配起来
  - 对序号前后的痕迹分类，取最可能成立的类型，将该类型的序号作为实际序号，合并字幕和视频
  - 默认使用弹幕序号标记与字幕/视频合并，除非特别指定使用偏移量
- 序号前后的痕迹有多种可能，以下列出可以想到的情况：
  1. `xxx[1]xxx`；`xxx[2]xxx`；...`xxx[10]xxx`
  1. `xxx[01]xxx`；`xxx[02]xxx`；...`xxx[10]xxx`
  1. `xxx[01]xxx`；...`xxx[10 END]xxx`
  1. `xxx[01]xxx`；...`xxx[10] END xxx`
  1. `xxx[01]xxx`；...`xxx[10]xxx`；`xxx[OVA]xxx`
  1. `xxx[01]xxx`；...`xxx[10]xxx`；`xxx[10.5]xxx`
  1. `xxx[01]xxx`；...`xxx[23]xxx`；`xxx[23β]xxx`
  1. `xxx[01]xxx(1A2C)`；`xxx[02]xxx(3B4D)`；...`xxx[10]xxx(CAFE)`
  1. `xxx[01]xxx Title1`；`xxx[02]xxx Title2`；...`xxx[10]xxx Title3`
  1. `xxx[S1E1]xxx`；`xxx[S1E2]xxx`；...`xxx[S1E10]xxx`；`xxx[S2E1]xxx`；`xxx[S2E2]xxx`；...`xxx[S2E10]xxx`
  1. `xxx[S1E1]xxx`；`xxx[S1E2]xxx`；...`xxx[S1E10]xxx`；`xxx[S2E11]xxx`；`xxx[S2E12]xxx`；...`xxx[S2E20]xxx`
- 由此我们可以总结出一些规律和我们需要注意的地方：
  - 序号可能是固定长度（0补齐）的，也可能是不固定长度的，我们应该把整段数字作为一个序号
  - 序号旁边可能有本集单独添加的标记（如`END`、`.5`等），不能单纯使用左边的后缀和右边的前缀进行匹配
  - 文件名旁边还可能有无法预知的其他字段（hash值、标题等），使用左边的前缀/右边的后缀之类更不可能，使用最长公共子串/子序列等算法也无法证明正确（虽然从实践上讲很难出现问题）
<!-- - 将具体问题抽象为算法问题如下：
  - 给定一组字符串，其中每个字符串包含零个至多个自然数，其中至多一个自然数被称为“集数”，这些“集数”有如下特征：
    - 如果有“集数”，那么一定有一个“集数”为`1`
    - 对任意一个大于1的“集数”`n`，一定存在一个“集数”`n-1`
  - 同时，这些字符串所在的位置 -->
- 目前想到的算法如下：
  - 对每个文件名中（`xxx[01]xxx`）找到的每个序号取其前后两部分（左边`xxx[`和右边`]xxx`）
  - 将所有左边和左边的前缀（`xxx[`；`xxx`；`xx`；`x`）组成后缀树；右边和右边的后缀组成前缀树
    <!-- - 剪枝：如果左边的一个前缀在前缀树上 -->
  - 对于每一对（前缀树节点，后缀树节点），找到所有同时满足二者（即：左边的前缀经过后缀树节点、右边的后缀经过前缀树节点）的文件名，对应的序号包括`1~n`的所有自然数（可以有重复，可以包括为`OVA`之类分配的特殊序号），那么这一对节点的结果记为（`n`，`前缀树节点高度`，`后缀树节点高度`，`所有左边前缀舍弃的字符总数`，`所有右边后缀舍弃的字符总数`）
  - 从实际的角度讲，让序号从1开始生长并逐渐剪枝更容易实现